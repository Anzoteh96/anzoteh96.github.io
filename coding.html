<!DOCTYPE html>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>
<link rel="stylesheet" href="css/imo_style.css" />
<script src="anzo_jsfn.js"></script>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codings</title>
        <body ng-app="">

            <div ng-include="'myheader.html'"></div>

        </body>
    <h1>My Coding Experience</h1>
</head>
<body>
    <span id="competitive_coding">
        <h2>Competitive Coding</h2>
        <p>
            I started coding in Feburary 2016, mainly to solve algorithmic problems appeared in various contests.
            My primary language is C++ (although I started picking up Python 2 recently for Datathon purposes).
            The collection of cool problems I have solved can be found <a href="https://github.com/Anzoteh96/Cpp-algorithms">here</a>.
        </p>
        <!--
        <div align="center" class="bigpic">
            <figure>
                <img src="images/leetcode_rating.JPG" alt="leetcode" width="500" />
                <figcaption>My Leetcode contest progress as of February, 2018. </figcaption>
            </figure>
        </div>
      -->
        <div align="center" class="bigpic">
            <figure>
                <img src="images/cf_rating.JPG" alt="codeforces" width="500" />
                <figcaption>Reached <i>Master</i> (ratings 2100) on Codeforces in August 2019! </figcaption>
                </figure>
        </div>
        <p>
            Some of the awards I have won on the online or physical programming platforms are:
            <ul>
                <li>USACO February 2018 Gold Division: Promoted to Platinum Division.</li>
                <li>Communitech Code-and-Win Competition, January 2018:</li>
                <ul>
                    <li>Final Round: Rank 15/46, score 428/450.</li>
                    <li>Preliminary Round: score 284/375 (threshold to advance: 185 points).</li>
                </ul>
                <li>HackerRank Week of Code 32: Gold medal (ranked 174/8433)</li>
                <ul>
                    <li>Promoted to O(1) rating category (top 1% among all users)</li>
                </ul>
                <li>HackerRank Week of Code 24: Gold medal (ranked 189/9133)</li>
                <li>LeetCode Weekly Contests:</li>
                <ul>
                    <li>Contest 70: ranked 29/2555.</li>
                    <li>Contest 45: ranked 38/2292.</li>
                    <li>Contest 43: ranked 78/2291.</li>
                    <li>Contest 41: ranked 99/2174.</li>
                    <li>Contest 34: ranked 26/1557.</li>
                </ul>
                <li>USACO December 2016: Perfect Score (Bronze and Silver Divisions)</li>
                <ul>
                    <li>Promoted to Gold Division</li>
                </ul>
            </ul>
            It's worth noting that my ability to code has also won and team and me the second place at the Waterloo Google Games on April 28, 2018, during which I nailed down 5 algorithmic- (and math-) puzzles for my team, resulting in us solving 11 puzzles in total!
        </p>
    </span>

    <span id="hackathon">
        <h2>Hackathon Experience</h2>
        <ol>
            <li>
                <h3>LifeLog, the first UOttaHacks </h3>
                <h4>Date: February 17-18. 2018</h4>
                <p>On GitHub, developers can showcase their progress by commiting changes of their own files. Yet sometimes they prefer spending time to enrich themselves through reading articles related to their ongoing side projects, or merely for interest. Hence, it might be misleading for people to think that they do not contribute much, and are therefore non-productive during the period.
                </p>
                <p>We developed a web application so that developers (or any users) can 'commit' their readings onto LifeLog. To be precise:
                    <ul>
                        <li>People can commit an article they find interesting onto LifeLog.</li>
                        <li>People can also highlight phrases they find interesting onto LifeLog. </li>
                    </ul>
                    My contribution to this application is the Chrome extension framework. To be precise, I started off by writing the manifest.js file (that is needed for most Chrome extension), before developing the main.js file by adding the chrome.addListener function: this allows the Chrome extension to send the commit to console log whenever a new article has been 'commited'.
                </p>
            </li>
            <li>
                <h3>Trading Simulator, <a href="http://www.rbcroyalbank.com/personal.html">Royal Bank of Canada</a>(RBC)'s The Next Great Innovator Hackathon</h3>
                <h4>Date: September 23-24, 2017</h4>
                <p>
                    My team agreed on building a <b>Trading Simulator</b> that opens to everyone to compete against RBC's trading strategy for the following two objectives:
                    <ul>
                        <li>To attract top performers into working in RBC and improve RBC's trading strategies. </li>
                        <li>To improve the trading stragies of RBC through 'learning' from the top performers. </li>
                    </ul>
                    Our team comprised a Business Analyst, a UI Designer, and three developers (me included).
                </p>
                <p>
                    In simulating the way in which an individual attempts to beat RBC by guessing the stock price at the next minute, a teammates posed me this question:
                    <q>how do you predict the stock price at the next minute given the prices in the past? </q>
                    After some comptemplation I noticed the similarity of this question to the classical problem of <a href="https://www.youtube.com/watch?v=LpjX3kHXcR0">finding the next number in a sequence</a>,
                    which immediately prompted me to use the <a href="http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html">Lagrange Interpolation Polynomial</a> to fit every point into a single polynomial.
                    The problems associated to this formula are:
                    <ul>
                        <li>Inefficient running time due to the need of recalculation of the data for every single computation. </li>
                        <li>Integer overflowing (even in Python) due to the multiplication of large number (say, hundreds or thousands) of variables. </li>
                        <li>Huge deviation of the next predicted number from the numbers in the original sequence (due to the high power of the leading coefficient) that renders the prediction inaccurate. </li>
                    </ul>
                    I later learned that this problem is named <a href="https://en.wikipedia.org/wiki/Overfitting">overfitting</a>.
                </p>
                <p>
                    In view of this I attempted the linear regression method: the results were getting better, but not quite there.
                    Nonetheless, this motivated the approach of fitting a polynomial with degree depending on the number of points we had in the past.
                    This was achieved by fitting the numbers into matrices in computing the coefficients of the resultant polynomial using numpy.linalg package.
                    It's then found that an optimal way (using this approach and given the dataset) was to set the degree of polynomial at $O(\sqrt[3]{n})$ where $n$ is the number of points.
                    This effectively capped my error at 4% in price prediction (around 1.5% on average).
                </p>
                <div align="center" class="bigpic">
                    <figure>
                        <img src="images/rbc_python.JPG" alt="Code Snippet" width="500" />
                        <figcaption>A snippet of my Python code written for the regression calculation by storing the values of $\sum x^k$ and $\sum yx^m$. </figcaption>
                    </figure>
                </div>
                <p>
                    Some other tasks I did during the Hackathon was to help debugging codes written by my teammates in Javascript, HTML and CSS (towards the deadline of the submission).
                </p>
                <h4>Languages: Python (numpy.linalg library), HTML, CSS, Javascript. </h4>
                <h4>Skills gained: a preliminary idea on how machine learning works. </h4>
            </li>
            <li>
                <h3>Idea Connector, Waterloo Equithon</h3>
                <h4>May 5-7, 2017</h4>
                <p>
                    This was my first Hackathon experience.
                    The problem that my teammates and I worked on was the fact that there were people with ideas and insights but do not have the skills to implement them.
                    On the other hand, there were also people with advanced skills in their related fields yet do not have the insights to see which problems to solve.
                    Hence we developed a website to connected the two types of people.
                </p>
                <h4>Languages: HTML, CSS, Javascript. </h4>
                <h4>Benefit gained: a motivation to develop my own website here. </h4>
            </li>
        </ol>
    </span>


    <span id="datathon">
        <h2>Datathon Experience: Waterloo Datathon 2017</h2>
        <p>
            On May 13, 2017, I was selected to take part in the Waterloo Datathon (through an assessment).
            The task given on the day was to draw conclusion based on the data on pickups by Uber and other transportation method in different areas.
            My teammates and I decided to relate this data to the crime rate happening in the respective cities (using another dataset we searched on our own).
            Using statisical languages like R and Python, we drew a conclusion that public transportation is less perferred in areas with high crime rates.
        </p>
        <h3>Languages: Python (panda package), R.</h3>
    </span>

    <span id="projects">
    <h2>Projects</h2>
    <ol>
        <li><a href = "https://github.com/Anzoteh96/extended-number">The C++ Extended Integer System (Ongoing)</a></li>
        <p>Inspired by the cyrptography research that I am undertaking in Summer 2018, I couldn't help but wonder: how to implement a system of numbers modulo n that provides a convenient method for addition, subtraction, multiplication and even integer division (inverse)? More generally, how can I implement features in C++ that offers cool mathematical things like what <a href = "http://www.sagemath.org:">SageMath.org</a> offers? Below are the framework I needed to do:
        </p>
        <ol>
            <li>The BigInt system in C++.
            </li>
            <p>The int type in C++ allows 32-bits of integer storage while the long long int type allows 64-bits. In order for a sagemath simulating system to be efficient, we must have a system that stores way beyond the prescribed 64 bits for integers. The features currently supported are as of below:
                <ul>
                    <li>Basic arithmetic (addition, subtraction, multiplication, integer division and remainder).
                    </li>
                    <li>Comparison (greater or less than, equality).</li>
                    <li>Bitwise shift (left shift << and right shift >>).</li>
                </ul>
            </p>
            <li>Number modulo n.
            </li>
            <p>The arithmetic operations are the same as the BigInt system, but there are a few differences:
                <ul>
                    <li>Ordering and comparison no longer makes sense here. </li>
                    <li>Division of integers can still return an integer without remainder provided that the divisor is relatively prime to n (for example, if n = 11 then 1/5=6). </li>
                    <li>Fast exponentiation can be done, i.e. the result of $k^m$ mod n can be found in polynomial time in log k, m and n. </li>
                </ul>
            </p>
        </ol>
        <p>The main challenge of this project is to optimize my library to the maximum possible while keeping the object-oriented development principle (single-responsibility principle, minimize coupling between modules, etc). In the very beginning, it takes 5 seconds to read, output, and perform all arithmetic operations on two 300-digit integers, and modular exponentiation seemed infeasible. Below is my journey to optimization in bringing 5 seconds to 0.016 seconds (300 times!) and modular arithmetic of 60-digit numbers from 232 seconds to 0.175 seconds (1000+ times!):
        </p>
        <ol>
            <li>By avoiding unnecessary recursion and recalculation in reading input (conversion from base 10 to base 2), which allowed my algorithm to go down to 2 seconds from 5. </li>
            <li>By decapsulating my objects when doing arithmetic operations (i.e. perform arithmetic on vectors instead of doing them repeatedly on BigInt to avoid unncessary constructor and destructor running) I successfully brought it down from 2 seconds to 0.37 seconds.
            </li>
            <li>Previously, modular exponentiation is still very slow: doing it for two 10-digit numbers takes more than 15 seconds. I brought this to around 2 seconds by simply decapsulating division and remainder process.</li>
            <li>Compiling with the O2 flag (optimization) made all process above finish executing in one-third of original time. </li>
            <li>Previously, my Karatsuba's algorithm involves creating new smaller vectors and perform recursion from there. By avoiding copying and performing recursion on a segment of the original vector instead, I gained 1/3 speedup overall.
            </li>
            <li>Finally, changing from Karatsuba's algorithm to Fast Fourier transform allows a whooping 5 to 6 times optimization on modular arithmetic of two 300-digit numbers modulo another 300-digit number. It also gives almost 3 times speedup on ordinary arithmetics. </li>
        </ol>

    </ol>
    </span>

    <span id="research">
        <h2>Research Experience</h2>
        <p>
            As mentioned in my home page, I just finished doing a research on finding weakly connected components in a graph.
            The task of finding a weakly connected component can be rephrased as below:
            <q>
                Given a group of people, some pairs of them are friends (and friendship is mutual).
                For each pair of people A and B, do there exist a set of people from the group,
                such that we can line them up with A on one end and B on the other end, and any two neighbouring people on the line are friends?
            </q>
            Although various algorithms exist (breadth-first search, depth-first search, quick-find, quick-union),
            most (if not all) of them cannot update the set of connected components efficiently in the case of edge deletion.
        </p>
        <p>
            A crucial observation in solving this mega-problem is that, in general, the probability of a connected component being split into two upon edge deletion is rather small.
            Having this in mind, and having familiarized myself with the existing algorithms in a static setting, I started off by modifying the features of the existing algorithms:
            <ul>
                <li>
                    Breadth-first search: record the distance of each vertex from a selected vertex of its component. Deletion of an edge joining vertices of the same distance does not change the connected components.
                </li>
                <li>
                    Quick-union: select some edges that will form a forest (that is, collection of trees). Deletion of edge that do not form a forest won't change the connected components.
                </li>
            </ul>
            As compared to the naive algorithm of repeating the same algorithm (used for static setting), these algorithms managed to reduce the running time by 5000 times.
        </p>
        <p>
            The final part of my research concerns about making these algorithms work in parallel processing (that is, multitasking).
            After designing the algorithm on paper, I explored two technologies: OpenMP and Message Passing Interface (MPI).
            Under the advice of my supervisor, I chose to move on with MPI due to the private memory assigned to each processor (which makes it easier to scale to big numbers).
            In the end of my research, I constructed a framework of the algorithms aforementioned that conatains the idea behind it.
        </p>
        <h3>
            Dataset used: 5 graphs with up to 105 million vertices and up to 2.6 billion edges.
        </h3>
        <h3>
            Language: C++.
        </h3>
        <h3>
            Proof of correctness: by comparing output with that produced by <a href="https://snap.stanford.edu/">Stanford Network Analysis Project (SNAP)</a>.
        </h3>
        <h3>
            Skills gained: Linux, debugging, parallel processing.
        </h3>
    </span id="research">
</body>
</html>
